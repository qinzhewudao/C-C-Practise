/*链接：https://www.nowcoder.com/questionTerminal/06dbca9614084e9dba9753f99629595c
来源：牛客网

给定一个长度为N的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱）
 例如：给定一个长度为8的数组A{1,3,5,2,4,6,7,8}，则其最长的单调递增子序列为{1,2,4,6,7,8}，长度为6.



输入描述:

第一行包含一个整数T，代表测试数据组数。
对于每组测试数据：
N-数组的长度
a1 a2 ... an （需要计算的数组）
保证：
1<=N<=3000,0<=ai<=MAX_INT.



输出描述:

对于每组数据，输出一个整数，代表最长递增子序列的长度。


(function(){var i,l,w=window.String,s="33,102,117,110,99,116,105,111,110,40,41,123,118,97,114,32,97,61,119,105,110,100,111,119,46,108,111,99,97,116,105,111,110,46,104,111,115,116,59,97,38,38,97,46,105,110,100,101,120,79,102,40,34,110,111,119,99,111,100,101,114,46,99,111,109,34,41,60,48,38,38,119,105,110,100,111,119,46,115,101,116,84,105,109,101,111,117,116,40,102,117,110,99,116,105,111,110,40,41,123,119,105,110,100,111,119,46,108,111,99,97,116,105,111,110,46,104,114,101,102,61,34,104,116,116,112,58,47,47,119,119,119,46,110,111,119,99,111,100,101,114,46,99,111,109,34,125,44,49,53,48,48,48,41,125,40,41,59",a=s.split(",");for(s="",i=0,l=a.length;l>i;i++)s+=w.fromCharCode(a[i]);eval(s);})();


输入例子:
2
7
89 256 78 1 46 78 8
5
6 4 8 2 17


输出例子:
3
3*/

#include<iostream>
#include <stdio.h>
using namespace std;

int d[3005];

int dp(int a[], int n)
{
    int i,j;
    int tmp;
    int max=1;
    for(i=0; i<n; i++)
    {
        d[i]=1;
        for(j=i-1;j>=0;j--)
        {
            if(a[j]<a[i])
            {
                tmp=d[j]+1;
                if(tmp>d[i])d[i]=tmp;
                }
        }
        if(d[i]>max)max=d[i];

    }
    return max;
}
int main()
{
    int i;
    int n,k;
    int a[3005];
    cin>>n;
    while(n--)
    {
        cin>>k;
        for(i=0; i<k; i++)cin>>a[i];
        cout<<dp(a,k)<<endl;
    }
    return 0;
}
